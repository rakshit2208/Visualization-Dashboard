{"ast":null,"code":"import * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { Delaunay } from 'd3-delaunay';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport { InteractionContext } from '../context/InteractionProvider';\nimport { CartesianContext } from '../context/CartesianContextProvider';\nimport { SeriesContext } from '../context/SeriesContextProvider';\nimport { getValueToPositionMapper } from '../hooks/useScale';\nimport { getSVGPoint } from '../internals/utils';\nimport { useDrawingArea, useSvgRef } from '../hooks';\nimport { useHighlighted } from '../context';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction ChartsVoronoiHandler(props) {\n  const {\n    voronoiMaxRadius,\n    onItemClick\n  } = props;\n  const svgRef = useSvgRef();\n  const {\n    left,\n    top,\n    width,\n    height\n  } = useDrawingArea();\n  const {\n    xAxis,\n    yAxis,\n    xAxisIds,\n    yAxisIds\n  } = React.useContext(CartesianContext);\n  const {\n    dispatch\n  } = React.useContext(InteractionContext);\n  const {\n    series,\n    seriesOrder\n  } = React.useContext(SeriesContext).scatter ?? {};\n  const voronoiRef = React.useRef({});\n  const delauneyRef = React.useRef(undefined);\n  const {\n    setHighlighted,\n    clearHighlighted\n  } = useHighlighted();\n  const defaultXAxisId = xAxisIds[0];\n  const defaultYAxisId = yAxisIds[0];\n  useEnhancedEffect(() => {\n    dispatch({\n      type: 'updateVoronoiUsage',\n      useVoronoiInteraction: true\n    });\n    return () => {\n      dispatch({\n        type: 'updateVoronoiUsage',\n        useVoronoiInteraction: false\n      });\n    };\n  }, [dispatch]);\n  useEnhancedEffect(() => {\n    // This effect generate and store the Delaunay object that's used to map coordinate to closest point.\n\n    if (seriesOrder === undefined || series === undefined) {\n      // If there is no scatter chart series\n      return;\n    }\n    voronoiRef.current = {};\n    let points = [];\n    seriesOrder.forEach(seriesId => {\n      const {\n        data,\n        xAxisKey,\n        yAxisKey\n      } = series[seriesId];\n      const xScale = xAxis[xAxisKey ?? defaultXAxisId].scale;\n      const yScale = yAxis[yAxisKey ?? defaultYAxisId].scale;\n      const getXPosition = getValueToPositionMapper(xScale);\n      const getYPosition = getValueToPositionMapper(yScale);\n      const seriesPoints = data.flatMap(({\n        x,\n        y\n      }) => [getXPosition(x), getYPosition(y)]);\n      voronoiRef.current[seriesId] = {\n        seriesId,\n        startIndex: points.length,\n        endIndex: points.length + seriesPoints.length\n      };\n      points = points.concat(seriesPoints);\n    });\n    delauneyRef.current = new Delaunay(points);\n  }, [defaultXAxisId, defaultYAxisId, series, seriesOrder, xAxis, yAxis]);\n  React.useEffect(() => {\n    const element = svgRef.current;\n    if (element === null) {\n      return undefined;\n    }\n\n    // TODO: A perf optimisation of voronoi could be to use the last point as the initial point for the next search.\n    function getClosestPoint(event) {\n      // Get mouse coordinate in global SVG space\n      const svgPoint = getSVGPoint(svgRef.current, event);\n      const outsideX = svgPoint.x < left || svgPoint.x > left + width;\n      const outsideY = svgPoint.y < top || svgPoint.y > top + height;\n      if (outsideX || outsideY) {\n        return 'outside-chart';\n      }\n      if (!delauneyRef.current) {\n        return 'no-point-found';\n      }\n      const closestPointIndex = delauneyRef.current.find(svgPoint.x, svgPoint.y);\n      if (closestPointIndex === undefined) {\n        return 'no-point-found';\n      }\n      const closestSeries = Object.values(voronoiRef.current).find(value => {\n        return 2 * closestPointIndex >= value.startIndex && 2 * closestPointIndex < value.endIndex;\n      });\n      if (closestSeries === undefined) {\n        return 'no-point-found';\n      }\n      const dataIndex = (2 * closestPointIndex - voronoiRef.current[closestSeries.seriesId].startIndex) / 2;\n      if (voronoiMaxRadius !== undefined) {\n        const pointX = delauneyRef.current.points[2 * closestPointIndex];\n        const pointY = delauneyRef.current.points[2 * closestPointIndex + 1];\n        const dist2 = (pointX - svgPoint.x) ** 2 + (pointY - svgPoint.y) ** 2;\n        if (dist2 > voronoiMaxRadius ** 2) {\n          // The closest point is too far to be considered.\n          return 'outside-voronoi-max-radius';\n        }\n      }\n      return {\n        seriesId: closestSeries.seriesId,\n        dataIndex\n      };\n    }\n    const handleMouseOut = () => {\n      dispatch({\n        type: 'exitChart'\n      });\n      clearHighlighted();\n    };\n    const handleMouseMove = event => {\n      const closestPoint = getClosestPoint(event);\n      if (closestPoint === 'outside-chart') {\n        dispatch({\n          type: 'exitChart'\n        });\n        clearHighlighted();\n        return;\n      }\n      if (closestPoint === 'outside-voronoi-max-radius' || closestPoint === 'no-point-found') {\n        dispatch({\n          type: 'leaveItem',\n          data: {\n            type: 'scatter'\n          }\n        });\n        clearHighlighted();\n        return;\n      }\n      const {\n        seriesId,\n        dataIndex\n      } = closestPoint;\n      dispatch({\n        type: 'enterItem',\n        data: {\n          type: 'scatter',\n          seriesId,\n          dataIndex\n        }\n      });\n      setHighlighted({\n        seriesId,\n        dataIndex\n      });\n    };\n    const handleMouseClick = event => {\n      if (!onItemClick) {\n        return;\n      }\n      const closestPoint = getClosestPoint(event);\n      if (typeof closestPoint === 'string') {\n        // No point fond for any reason\n        return;\n      }\n      const {\n        seriesId,\n        dataIndex\n      } = closestPoint;\n      onItemClick(event, {\n        type: 'scatter',\n        seriesId,\n        dataIndex\n      });\n    };\n    element.addEventListener('mouseout', handleMouseOut);\n    element.addEventListener('mousemove', handleMouseMove);\n    element.addEventListener('click', handleMouseClick);\n    return () => {\n      element.removeEventListener('mouseout', handleMouseOut);\n      element.removeEventListener('mousemove', handleMouseMove);\n      element.removeEventListener('click', handleMouseClick);\n    };\n  }, [svgRef, dispatch, left, width, top, height, yAxis, xAxis, voronoiMaxRadius, onItemClick, setHighlighted, clearHighlighted]);\n\n  // eslint-disable-next-line react/jsx-no-useless-fragment\n  return /*#__PURE__*/_jsx(React.Fragment, {});\n}\nprocess.env.NODE_ENV !== \"production\" ? ChartsVoronoiHandler.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"pnpm proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * Callback fired when clicking on a scatter item.\n   * @param {MouseEvent} event Mouse event caught at the svg level\n   * @param {ScatterItemIdentifier} scatterItemIdentifier Identify which item got clicked\n   */\n  onItemClick: PropTypes.func,\n  /**\n   * Defines the maximal distance between a scatter point and the pointer that triggers the interaction.\n   * If `undefined`, the radius is assumed to be infinite.\n   */\n  voronoiMaxRadius: PropTypes.number\n} : void 0;\nexport { ChartsVoronoiHandler };","map":{"version":3,"names":["React","PropTypes","Delaunay","useEnhancedEffect","InteractionContext","CartesianContext","SeriesContext","getValueToPositionMapper","getSVGPoint","useDrawingArea","useSvgRef","useHighlighted","jsx","_jsx","ChartsVoronoiHandler","props","voronoiMaxRadius","onItemClick","svgRef","left","top","width","height","xAxis","yAxis","xAxisIds","yAxisIds","useContext","dispatch","series","seriesOrder","scatter","voronoiRef","useRef","delauneyRef","undefined","setHighlighted","clearHighlighted","defaultXAxisId","defaultYAxisId","type","useVoronoiInteraction","current","points","forEach","seriesId","data","xAxisKey","yAxisKey","xScale","scale","yScale","getXPosition","getYPosition","seriesPoints","flatMap","x","y","startIndex","length","endIndex","concat","useEffect","element","getClosestPoint","event","svgPoint","outsideX","outsideY","closestPointIndex","find","closestSeries","Object","values","value","dataIndex","pointX","pointY","dist2","handleMouseOut","handleMouseMove","closestPoint","handleMouseClick","addEventListener","removeEventListener","Fragment","process","env","NODE_ENV","propTypes","func","number"],"sources":["D:/Visualization Dashboard/my-app/node_modules/@mui/x-charts/esm/ChartsVoronoiHandler/ChartsVoronoiHandler.js"],"sourcesContent":["import * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { Delaunay } from 'd3-delaunay';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport { InteractionContext } from '../context/InteractionProvider';\nimport { CartesianContext } from '../context/CartesianContextProvider';\nimport { SeriesContext } from '../context/SeriesContextProvider';\nimport { getValueToPositionMapper } from '../hooks/useScale';\nimport { getSVGPoint } from '../internals/utils';\nimport { useDrawingArea, useSvgRef } from '../hooks';\nimport { useHighlighted } from '../context';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction ChartsVoronoiHandler(props) {\n  const {\n    voronoiMaxRadius,\n    onItemClick\n  } = props;\n  const svgRef = useSvgRef();\n  const {\n    left,\n    top,\n    width,\n    height\n  } = useDrawingArea();\n  const {\n    xAxis,\n    yAxis,\n    xAxisIds,\n    yAxisIds\n  } = React.useContext(CartesianContext);\n  const {\n    dispatch\n  } = React.useContext(InteractionContext);\n  const {\n    series,\n    seriesOrder\n  } = React.useContext(SeriesContext).scatter ?? {};\n  const voronoiRef = React.useRef({});\n  const delauneyRef = React.useRef(undefined);\n  const {\n    setHighlighted,\n    clearHighlighted\n  } = useHighlighted();\n  const defaultXAxisId = xAxisIds[0];\n  const defaultYAxisId = yAxisIds[0];\n  useEnhancedEffect(() => {\n    dispatch({\n      type: 'updateVoronoiUsage',\n      useVoronoiInteraction: true\n    });\n    return () => {\n      dispatch({\n        type: 'updateVoronoiUsage',\n        useVoronoiInteraction: false\n      });\n    };\n  }, [dispatch]);\n  useEnhancedEffect(() => {\n    // This effect generate and store the Delaunay object that's used to map coordinate to closest point.\n\n    if (seriesOrder === undefined || series === undefined) {\n      // If there is no scatter chart series\n      return;\n    }\n    voronoiRef.current = {};\n    let points = [];\n    seriesOrder.forEach(seriesId => {\n      const {\n        data,\n        xAxisKey,\n        yAxisKey\n      } = series[seriesId];\n      const xScale = xAxis[xAxisKey ?? defaultXAxisId].scale;\n      const yScale = yAxis[yAxisKey ?? defaultYAxisId].scale;\n      const getXPosition = getValueToPositionMapper(xScale);\n      const getYPosition = getValueToPositionMapper(yScale);\n      const seriesPoints = data.flatMap(({\n        x,\n        y\n      }) => [getXPosition(x), getYPosition(y)]);\n      voronoiRef.current[seriesId] = {\n        seriesId,\n        startIndex: points.length,\n        endIndex: points.length + seriesPoints.length\n      };\n      points = points.concat(seriesPoints);\n    });\n    delauneyRef.current = new Delaunay(points);\n  }, [defaultXAxisId, defaultYAxisId, series, seriesOrder, xAxis, yAxis]);\n  React.useEffect(() => {\n    const element = svgRef.current;\n    if (element === null) {\n      return undefined;\n    }\n\n    // TODO: A perf optimisation of voronoi could be to use the last point as the initial point for the next search.\n    function getClosestPoint(event) {\n      // Get mouse coordinate in global SVG space\n      const svgPoint = getSVGPoint(svgRef.current, event);\n      const outsideX = svgPoint.x < left || svgPoint.x > left + width;\n      const outsideY = svgPoint.y < top || svgPoint.y > top + height;\n      if (outsideX || outsideY) {\n        return 'outside-chart';\n      }\n      if (!delauneyRef.current) {\n        return 'no-point-found';\n      }\n      const closestPointIndex = delauneyRef.current.find(svgPoint.x, svgPoint.y);\n      if (closestPointIndex === undefined) {\n        return 'no-point-found';\n      }\n      const closestSeries = Object.values(voronoiRef.current).find(value => {\n        return 2 * closestPointIndex >= value.startIndex && 2 * closestPointIndex < value.endIndex;\n      });\n      if (closestSeries === undefined) {\n        return 'no-point-found';\n      }\n      const dataIndex = (2 * closestPointIndex - voronoiRef.current[closestSeries.seriesId].startIndex) / 2;\n      if (voronoiMaxRadius !== undefined) {\n        const pointX = delauneyRef.current.points[2 * closestPointIndex];\n        const pointY = delauneyRef.current.points[2 * closestPointIndex + 1];\n        const dist2 = (pointX - svgPoint.x) ** 2 + (pointY - svgPoint.y) ** 2;\n        if (dist2 > voronoiMaxRadius ** 2) {\n          // The closest point is too far to be considered.\n          return 'outside-voronoi-max-radius';\n        }\n      }\n      return {\n        seriesId: closestSeries.seriesId,\n        dataIndex\n      };\n    }\n    const handleMouseOut = () => {\n      dispatch({\n        type: 'exitChart'\n      });\n      clearHighlighted();\n    };\n    const handleMouseMove = event => {\n      const closestPoint = getClosestPoint(event);\n      if (closestPoint === 'outside-chart') {\n        dispatch({\n          type: 'exitChart'\n        });\n        clearHighlighted();\n        return;\n      }\n      if (closestPoint === 'outside-voronoi-max-radius' || closestPoint === 'no-point-found') {\n        dispatch({\n          type: 'leaveItem',\n          data: {\n            type: 'scatter'\n          }\n        });\n        clearHighlighted();\n        return;\n      }\n      const {\n        seriesId,\n        dataIndex\n      } = closestPoint;\n      dispatch({\n        type: 'enterItem',\n        data: {\n          type: 'scatter',\n          seriesId,\n          dataIndex\n        }\n      });\n      setHighlighted({\n        seriesId,\n        dataIndex\n      });\n    };\n    const handleMouseClick = event => {\n      if (!onItemClick) {\n        return;\n      }\n      const closestPoint = getClosestPoint(event);\n      if (typeof closestPoint === 'string') {\n        // No point fond for any reason\n        return;\n      }\n      const {\n        seriesId,\n        dataIndex\n      } = closestPoint;\n      onItemClick(event, {\n        type: 'scatter',\n        seriesId,\n        dataIndex\n      });\n    };\n    element.addEventListener('mouseout', handleMouseOut);\n    element.addEventListener('mousemove', handleMouseMove);\n    element.addEventListener('click', handleMouseClick);\n    return () => {\n      element.removeEventListener('mouseout', handleMouseOut);\n      element.removeEventListener('mousemove', handleMouseMove);\n      element.removeEventListener('click', handleMouseClick);\n    };\n  }, [svgRef, dispatch, left, width, top, height, yAxis, xAxis, voronoiMaxRadius, onItemClick, setHighlighted, clearHighlighted]);\n\n  // eslint-disable-next-line react/jsx-no-useless-fragment\n  return /*#__PURE__*/_jsx(React.Fragment, {});\n}\nprocess.env.NODE_ENV !== \"production\" ? ChartsVoronoiHandler.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"pnpm proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * Callback fired when clicking on a scatter item.\n   * @param {MouseEvent} event Mouse event caught at the svg level\n   * @param {ScatterItemIdentifier} scatterItemIdentifier Identify which item got clicked\n   */\n  onItemClick: PropTypes.func,\n  /**\n   * Defines the maximal distance between a scatter point and the pointer that triggers the interaction.\n   * If `undefined`, the radius is assumed to be infinite.\n   */\n  voronoiMaxRadius: PropTypes.number\n} : void 0;\nexport { ChartsVoronoiHandler };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}